CJSXTransformer = {};
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = require('./lib/transformer').transform;

},{"./lib/transformer":9}],2:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
var buildLocationData, extend, flatten, last, repeat, syntaxErrorToString, _ref;

exports.starts = function(string, literal, start) {
  return literal === string.substr(start, literal.length);
};

exports.ends = function(string, literal, back) {
  var len;
  len = literal.length;
  return literal === string.substr(string.length - len - (back || 0), len);
};

exports.repeat = repeat = function(str, n) {
  var res;
  res = '';
  while (n > 0) {
    if (n & 1) {
      res += str;
    }
    n >>>= 1;
    str += str;
  }
  return res;
};

exports.compact = function(array) {
  var item, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = array.length; _i < _len; _i++) {
    item = array[_i];
    if (item) {
      _results.push(item);
    }
  }
  return _results;
};

exports.count = function(string, substr) {
  var num, pos;
  num = pos = 0;
  if (!substr.length) {
    return 1 / 0;
  }
  while (pos = 1 + string.indexOf(substr, pos)) {
    num++;
  }
  return num;
};

exports.merge = function(options, overrides) {
  return extend(extend({}, options), overrides);
};

extend = exports.extend = function(object, properties) {
  var key, val;
  for (key in properties) {
    val = properties[key];
    object[key] = val;
  }
  return object;
};

exports.flatten = flatten = function(array) {
  var element, flattened, _i, _len;
  flattened = [];
  for (_i = 0, _len = array.length; _i < _len; _i++) {
    element = array[_i];
    if (element instanceof Array) {
      flattened = flattened.concat(flatten(element));
    } else {
      flattened.push(element);
    }
  }
  return flattened;
};

exports.del = function(obj, key) {
  var val;
  val = obj[key];
  delete obj[key];
  return val;
};

exports.last = last = function(array, back) {
  return array[array.length - (back || 0) - 1];
};

exports.some = (_ref = Array.prototype.some) != null ? _ref : function(fn) {
  var e, _i, _len;
  for (_i = 0, _len = this.length; _i < _len; _i++) {
    e = this[_i];
    if (fn(e)) {
      return true;
    }
  }
  return false;
};

exports.invertLiterate = function(code) {
  var line, lines, maybe_code;
  maybe_code = true;
  lines = (function() {
    var _i, _len, _ref1, _results;
    _ref1 = code.split('\n');
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      line = _ref1[_i];
      if (maybe_code && /^([ ]{4}|[ ]{0,3}\t)/.test(line)) {
        _results.push(line);
      } else if (maybe_code = /^\s*$/.test(line)) {
        _results.push(line);
      } else {
        _results.push('# ' + line);
      }
    }
    return _results;
  })();
  return lines.join('\n');
};

buildLocationData = function(first, last) {
  if (!last) {
    return first;
  } else {
    return {
      first_line: first.first_line,
      first_column: first.first_column,
      last_line: last.last_line,
      last_column: last.last_column
    };
  }
};

exports.addLocationDataFn = function(first, last) {
  return function(obj) {
    if (((typeof obj) === 'object') && (!!obj['updateLocationDataIfMissing'])) {
      obj.updateLocationDataIfMissing(buildLocationData(first, last));
    }
    return obj;
  };
};

exports.locationDataToString = function(obj) {
  var locationData;
  if (("2" in obj) && ("first_line" in obj[2])) {
    locationData = obj[2];
  } else if ("first_line" in obj) {
    locationData = obj;
  }
  if (locationData) {
    return ("" + (locationData.first_line + 1) + ":" + (locationData.first_column + 1) + "-") + ("" + (locationData.last_line + 1) + ":" + (locationData.last_column + 1));
  } else {
    return "No location data";
  }
};

exports.baseFileName = function(file, stripExt, useWinPathSep) {
  var parts, pathSep;
  if (stripExt == null) {
    stripExt = false;
  }
  if (useWinPathSep == null) {
    useWinPathSep = false;
  }
  pathSep = useWinPathSep ? /\\|\// : /\//;
  parts = file.split(pathSep);
  file = parts[parts.length - 1];
  if (!(stripExt && file.indexOf('.') >= 0)) {
    return file;
  }
  parts = file.split('.');
  parts.pop();
  if (parts[parts.length - 1] === 'coffee' && parts.length > 1) {
    parts.pop();
  }
  return parts.join('.');
};

exports.isCoffee = function(file) {
  return /\.((lit)?coffee|coffee\.md)$/.test(file);
};

exports.isLiterate = function(file) {
  return /\.(litcoffee|coffee\.md)$/.test(file);
};

exports.throwSyntaxError = function(message, location) {
  var error;
  error = new SyntaxError(message);
  error.location = location;
  error.toString = syntaxErrorToString;
  error.stack = error.toString();
  throw error;
};

exports.updateSyntaxError = function(error, code, filename) {
  if (error.toString === syntaxErrorToString) {
    error.code || (error.code = code);
    error.filename || (error.filename = filename);
    error.stack = error.toString();
  }
  return error;
};

syntaxErrorToString = function() {
  var codeLine, colorize, colorsEnabled, end, filename, first_column, first_line, last_column, last_line, marker, start, _ref1, _ref2;
  if (!(this.code && this.location)) {
    return Error.prototype.toString.call(this);
  }
  _ref1 = this.location, first_line = _ref1.first_line, first_column = _ref1.first_column, last_line = _ref1.last_line, last_column = _ref1.last_column;
  if (last_line == null) {
    last_line = first_line;
  }
  if (last_column == null) {
    last_column = first_column;
  }
  filename = this.filename || '[stdin]';
  codeLine = this.code.split('\n')[first_line];
  start = first_column;
  end = first_line === last_line ? last_column + 1 : codeLine.length;
  marker = repeat(' ', start) + repeat('^', end - start);
  if (typeof process !== "undefined" && process !== null) {
    colorsEnabled = process.stdout.isTTY && !process.env.NODE_DISABLE_COLORS;
  }
  if ((_ref2 = this.colorful) != null ? _ref2 : colorsEnabled) {
    colorize = function(str) {
      return "\x1B[1;31m" + str + "\x1B[0m";
    };
    codeLine = codeLine.slice(0, start) + colorize(codeLine.slice(start, end)) + codeLine.slice(end);
    marker = colorize(marker);
  }
  return "" + filename + ":" + (first_line + 1) + ":" + (first_column + 1) + ": error: " + this.message + "\n" + codeLine + "\n" + marker;
};

exports.nameWhitespaceCharacter = function(string) {
  switch (string) {
    case ' ':
      return 'space';
    case '\n':
      return 'newline';
    case '\r':
      return 'carriage return';
    case '\t':
      return 'tab';
    default:
      return string;
  }
};

}).call(this,require("q+64fw"))
},{"q+64fw":11}],3:[function(require,module,exports){
// from react-tools/vendor/fbtransform/transforms/xjs.js

module.exports = {
  a: true,
  abbr: true,
  address: true,
  applet: true,
  area: true,
  article: true,
  aside: true,
  audio: true,
  b: true,
  base: true,
  bdi: true,
  bdo: true,
  big: true,
  blockquote: true,
  body: true,
  br: true,
  button: true,
  canvas: true,
  caption: true,
  circle: true,
  cite: true,
  code: true,
  col: true,
  colgroup: true,
  command: true,
  data: true,
  datalist: true,
  dd: true,
  defs: true,
  del: true,
  details: true,
  dfn: true,
  dialog: true,
  div: true,
  dl: true,
  dt: true,
  ellipse: true,
  em: true,
  embed: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  g: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  head: true,
  header: true,
  hgroup: true,
  hr: true,
  html: true,
  i: true,
  iframe: true,
  img: true,
  input: true,
  ins: true,
  kbd: true,
  keygen: true,
  label: true,
  legend: true,
  li: true,
  line: true,
  linearGradient: true,
  link: true,
  main: true,
  map: true,
  mark: true,
  marquee: true,
  menu: true,
  menuitem: true,
  meta: true,
  meter: true,
  nav: true,
  noscript: true,
  object: true,
  ol: true,
  optgroup: true,
  option: true,
  output: true,
  p: true,
  param: true,
  path: true,
  polygon: true,
  polyline: true,
  pre: true,
  progress: true,
  q: true,
  radialGradient: true,
  rect: true,
  rp: true,
  rt: true,
  ruby: true,
  s: true,
  samp: true,
  script: true,
  section: true,
  select: true,
  small: true,
  source: true,
  span: true,
  stop: true,
  strong: true,
  style: true,
  sub: true,
  summary: true,
  sup: true,
  svg: true,
  table: true,
  tbody: true,
  td: true,
  text: true,
  textarea: true,
  tfoot: true,
  th: true,
  thead: true,
  time: true,
  title: true,
  tr: true,
  track: true,
  u: true,
  ul: true,
  'var': true,
  video: true,
  wbr: true
};
},{}],4:[function(require,module,exports){
/** Function count the occurrences of substring in a string;
 * @param {String} string   Required. The string;
 * @param {String} subString    Required. The string to search for;
 * @param {Boolean} allowOverlapping    Optional. Default: false;
 */
function occurrences(string, subString, allowOverlapping){

    string+=""; subString+="";
    if(subString.length<=0) return string.length+1;

    var n=0, pos=0;
    var step=(allowOverlapping)?(1):(subString.length);

    while(true){
        pos=string.indexOf(subString,pos);
        if(pos>=0){ n++; pos+=step; } else break;
    }
    return(n);
}

},{}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var $, BOM, CLOSING_TAG, COMMENT, HEREDOC, HEREGEX, JSTOKEN, OPENING_TAG, PRAGMA, Parser, REGEX, SIMPLESTR, TAG_ATTRIBUTES, TRAILING_SPACES, WHITESPACE, compact, count, inspect, last, locationDataToString, parseTreeBranchNode, parseTreeLeafNode, repeat, starts, throwSyntaxError, util, _ref;

util = require('util');

_ref = require('./helpers'), count = _ref.count, starts = _ref.starts, compact = _ref.compact, last = _ref.last, repeat = _ref.repeat, locationDataToString = _ref.locationDataToString, throwSyntaxError = _ref.throwSyntaxError;

$ = require('./symbols');

inspect = function(value) {
  return util.inspect(value, {
    showHidden: true,
    depth: null
  });
};

parseTreeLeafNode = function(type, value) {
  if (value == null) {
    value = null;
  }
  return {
    type: type,
    value: value
  };
};

parseTreeBranchNode = function(type, value, children) {
  if (value == null) {
    value = null;
  }
  if (children == null) {
    children = [];
  }
  return {
    type: type,
    value: value,
    children: children
  };
};

module.exports = Parser = (function() {
  function Parser() {}

  Parser.prototype.parse = function(code, opts) {
    var consumed, i, message, _ref1;
    this.opts = opts != null ? opts : {};
    this.parseTree = parseTreeBranchNode(this.opts.root || $.ROOT);
    this.activeStates = [this.parseTree];
    this.chunkLine = 0;
    this.chunkColumn = 0;
    this.cjsxPragmaChecked = false;
    code = this.clean(code);
    i = 0;
    while ((this.chunk = code.slice(i))) {
      if (this.activeStates.length === 0) {
        break;
      }
      consumed = (this.currentState() !== $.CJSX_EL && this.currentState() !== $.CJSX_ATTRIBUTES ? this.csComment() || this.csHeredoc() || this.csString() || this.csRegex() || this.jsEscaped() : void 0) || this.cjsxStart() || this.cjsxAttribute() || this.cjsxEscape() || this.cjsxUnescape() || this.cjsxEnd() || this.cjsxText() || this.coffeescriptCode();
      _ref1 = this.getLineAndColumnFromChunk(consumed), this.chunkLine = _ref1[0], this.chunkColumn = _ref1[1];
      i += consumed;
    }
    if ((this.activeBranchNode() != null) && this.activeBranchNode() !== this.parseTree) {
      message = "Unexpected end of input: unclosed " + (this.currentState());
      throwSyntaxError(message, {
        first_line: this.chunkLine,
        first_column: this.chunkColumn
      });
    }
    this.remainder = code.slice(i);
    if (!this.opts.recursive) {
      if (this.remainder.length) {
        throwSyntaxError("Unexpected return from root state", {
          first_line: this.chunkLine,
          first_column: this.chunkColumn
        });
      }
    }
    return this.parseTree;
  };

  Parser.prototype.csComment = function() {
    var comment, here, match, pragmaMatch, prefix;
    if (!(match = this.chunk.match(COMMENT))) {
      return 0;
    }
    comment = match[0], here = match[1];
    if (!this.cjsxPragmaChecked) {
      this.cjsxPragmaChecked = true;
      if (pragmaMatch = comment.match(PRAGMA)) {
        if (pragmaMatch && pragmaMatch[1] && pragmaMatch[1].length) {
          prefix = pragmaMatch[1];
        } else {
          prefix = 'React.DOM';
        }
        this.addLeafNodeToActiveBranch(parseTreeLeafNode($.CJSX_PRAGMA, prefix));
        return comment.length;
      }
    }
    this.addLeafNodeToActiveBranch(parseTreeLeafNode($.CS_COMMENT, comment));
    return comment.length;
  };

  Parser.prototype.csHeredoc = function() {
    var heredoc, match;
    if (!(match = HEREDOC.exec(this.chunk))) {
      return 0;
    }
    heredoc = match[0];
    this.addLeafNodeToActiveBranch(parseTreeLeafNode($.CS_HEREDOC, heredoc));
    return heredoc.length;
  };

  Parser.prototype.csString = function() {
    var quote, string;
    switch (quote = this.chunk.charAt(0)) {
      case "'":
        string = SIMPLESTR.exec(this.chunk)[0];
        break;
      case '"':
        string = this.balancedString(this.chunk, '"');
    }
    if (!string) {
      return 0;
    }
    this.addLeafNodeToActiveBranch(parseTreeLeafNode($.CS_STRING, string));
    return string.length;
  };

  Parser.prototype.csRegex = function() {
    var flags, length, match, regex, _ref1;
    if (this.chunk.charAt(0) !== '/') {
      return 0;
    }
    if (length = this.csHeregex()) {
      return length;
    }
    if (!(match = REGEX.exec(this.chunk))) {
      return 0;
    }
    _ref1 = match, match = _ref1[0], regex = _ref1[1], flags = _ref1[2];
    if (regex.indexOf("\n") > -1) {
      return 0;
    }
    if (regex === '//') {
      return 0;
    }
    this.addLeafNodeToActiveBranch(parseTreeLeafNode($.CS_REGEX, match));
    return match.length;
  };

  Parser.prototype.csHeregex = function() {
    var body, flags, heregex, match;
    if (!(match = HEREGEX.exec(this.chunk))) {
      return 0;
    }
    heregex = match[0], body = match[1], flags = match[2];
    this.addLeafNodeToActiveBranch(parseTreeLeafNode($.CS_HEREGEX, heregex));
    return heregex.length;
  };

  Parser.prototype.jsEscaped = function() {
    var match, script;
    if (!(this.chunk.charAt(0) === '`' && (match = JSTOKEN.exec(this.chunk)))) {
      return 0;
    }
    script = match[0];
    this.addLeafNodeToActiveBranch(parseTreeLeafNode($.JS_ESC, script));
    return script.length;
  };

  Parser.prototype.cjsxStart = function() {
    var attributesText, input, match, selfClosing, tagName;
    if (!(match = OPENING_TAG.exec(this.chunk))) {
      return 0;
    }
    input = match[0], tagName = match[1], attributesText = match[2], selfClosing = match[3];
    if (!(selfClosing || this.chunk.indexOf("</" + tagName + ">", input.length) > -1)) {
      return 0;
    }
    this.pushActiveBranchNode(parseTreeBranchNode($.CJSX_EL, tagName));
    this.pushActiveBranchNode(parseTreeBranchNode($.CJSX_ATTRIBUTES));
    return 1 + tagName.length;
  };

  Parser.prototype.cjsxAttribute = function() {
    var attrName, bareVal, cjsxEscVal, doubleQuotedVal, input, match, singleQuotedVal, whitespace;
    if (this.currentState() !== $.CJSX_ATTRIBUTES) {
      return 0;
    }
    if (this.chunk.charAt(0) === '/') {
      if (this.chunk.charAt(1) === '>') {
        this.popActiveBranchNode();
        this.popActiveBranchNode();
        return 2;
      } else {
        throwSyntaxError("/ without immediately following > in CJSX tag " + (this.peekActiveState(2).value), {
          first_line: this.chunkLine,
          first_column: this.chunkColumn
        });
      }
    }
    if (this.chunk.charAt(0) === '>') {
      this.popActiveBranchNode();
      return 1;
    }
    if (!(match = TAG_ATTRIBUTES.exec(this.chunk))) {
      return 0;
    }
    input = match[0], attrName = match[1], doubleQuotedVal = match[2], singleQuotedVal = match[3], cjsxEscVal = match[4], bareVal = match[5], whitespace = match[6];
    if (attrName) {
      if (doubleQuotedVal) {
        this.addLeafNodeToActiveBranch(parseTreeBranchNode($.CJSX_ATTR_PAIR, null, [parseTreeLeafNode($.CJSX_ATTR_KEY, "\"" + attrName + "\""), parseTreeLeafNode($.CJSX_ATTR_VAL, "\"" + doubleQuotedVal + "\"")]));
        return input.length;
      } else if (singleQuotedVal) {
        this.addLeafNodeToActiveBranch(parseTreeBranchNode($.CJSX_ATTR_PAIR, null, [parseTreeLeafNode($.CJSX_ATTR_KEY, "\"" + attrName + "\""), parseTreeLeafNode($.CJSX_ATTR_VAL, "'" + singleQuotedVal + "'")]));
        return input.length;
      } else if (cjsxEscVal) {
        this.pushActiveBranchNode(parseTreeBranchNode($.CJSX_ATTR_PAIR));
        this.addLeafNodeToActiveBranch(parseTreeLeafNode($.CJSX_ATTR_KEY, "\"" + attrName + "\""));
        return input.indexOf('{');
      } else if (bareVal) {
        this.addLeafNodeToActiveBranch(parseTreeBranchNode($.CJSX_ATTR_PAIR, null, [parseTreeLeafNode($.CJSX_ATTR_KEY, "\"" + attrName + "\""), parseTreeLeafNode($.CJSX_ATTR_VAL, bareVal)]));
        return input.length;
      } else {
        this.addLeafNodeToActiveBranch(parseTreeBranchNode($.CJSX_ATTR_PAIR, null, [parseTreeLeafNode($.CJSX_ATTR_KEY, "\"" + attrName + "\""), parseTreeLeafNode($.CJSX_ATTR_VAL, 'true')]));
        return input.length;
      }
    } else if (whitespace) {
      this.addLeafNodeToActiveBranch(parseTreeLeafNode($.CJSX_WHITESPACE, whitespace));
      return input.length;
    } else {
      return throwSyntaxError("Invalid attribute " + input + " in CJSX tag " + (this.peekActiveState(2).value), {
        first_line: this.chunkLine,
        first_column: this.chunkColumn
      });
    }
  };

  Parser.prototype.cjsxEscape = function() {
    if (!(this.chunk.charAt(0) === '{' && this.currentState() === $.CJSX_EL || this.currentState() === $.CJSX_ATTR_PAIR)) {
      return 0;
    }
    this.pushActiveBranchNode(parseTreeBranchNode($.CJSX_ESC));
    this.activeBranchNode().stack = 1;
    return 1;
  };

  Parser.prototype.cjsxUnescape = function() {
    if (!(this.currentState() === $.CJSX_ESC && this.chunk.charAt(0) === '}')) {
      return 0;
    }
    if (this.activeBranchNode().stack === 0) {
      this.popActiveBranchNode();
      if (this.currentState() === $.CJSX_ATTR_PAIR) {
        this.popActiveBranchNode();
      }
      return 1;
    } else {
      return 0;
    }
  };

  Parser.prototype.cjsxEnd = function() {
    var input, match, tagName;
    if (this.currentState() !== $.CJSX_EL) {
      return 0;
    }
    if (!(match = CLOSING_TAG.exec(this.chunk))) {
      return 0;
    }
    input = match[0], tagName = match[1];
    if (tagName !== this.activeBranchNode().value) {
      throwSyntaxError("opening CJSX tag " + (this.activeBranchNode().value) + " doesn't match closing CJSX tag " + tagName, {
        first_line: this.chunkLine,
        first_column: this.chunkColumn
      });
    }
    this.popActiveBranchNode();
    return input.length;
  };

  Parser.prototype.cjsxText = function() {
    if (this.currentState() !== $.CJSX_EL) {
      return 0;
    }
    if (this.newestNode().type !== $.CJSX_TEXT) {
      this.addLeafNodeToActiveBranch(parseTreeLeafNode($.CJSX_TEXT, ''));
    }
    this.newestNode().value += this.chunk.charAt(0);
    return 1;
  };

  Parser.prototype.coffeescriptCode = function() {
    if (this.currentState() === $.CJSX_ESC) {
      if (this.chunk.charAt(0) === '{') {
        this.activeBranchNode().stack++;
      } else if (this.chunk.charAt(0) === '}') {
        this.activeBranchNode().stack--;
        if (this.activeBranchNode().stack === 0) {
          return 0;
        }
      }
    }
    if (this.newestNode().type !== $.CS) {
      this.addLeafNodeToActiveBranch(parseTreeLeafNode($.CS, ''));
    }
    this.newestNode().value += this.chunk.charAt(0);
    return 1;
  };

  Parser.prototype.activeBranchNode = function() {
    return last(this.activeStates);
  };

  Parser.prototype.peekActiveState = function(depth) {
    if (depth == null) {
      depth = 1;
    }
    return this.activeStates.slice(-depth)[0];
  };

  Parser.prototype.currentState = function() {
    return this.activeBranchNode().type;
  };

  Parser.prototype.newestNode = function() {
    return last(this.activeBranchNode().children) || this.activeBranchNode();
  };

  Parser.prototype.pushActiveBranchNode = function(node) {
    this.activeBranchNode().children.push(node);
    return this.activeStates.push(node);
  };

  Parser.prototype.popActiveBranchNode = function() {
    return this.activeStates.pop();
  };

  Parser.prototype.addLeafNodeToActiveBranch = function(node) {
    return this.activeBranchNode().children.push(node);
  };

  Parser.prototype.clean = function(code) {
    if (code.charCodeAt(0) === BOM) {
      code = code.slice(1);
    }
    return code;
  };

  Parser.prototype.getLineAndColumnFromChunk = function(offset) {
    var column, lineCount, lines, string;
    if (offset === 0) {
      return [this.chunkLine, this.chunkColumn];
    }
    if (offset >= this.chunk.length) {
      string = this.chunk;
    } else {
      string = this.chunk.slice(0, +(offset - 1) + 1 || 9e9);
    }
    lineCount = count(string, '\n');
    column = this.chunkColumn;
    if (lineCount > 0) {
      lines = string.split('\n');
      column = last(lines).length;
    } else {
      column += string.length;
    }
    return [this.chunkLine + lineCount, column];
  };

  Parser.prototype.balancedString = function(str, end) {
    var continueCount, i, letter, match, prev, stack, _i, _ref1;
    continueCount = 0;
    stack = [end];
    for (i = _i = 1, _ref1 = str.length; 1 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
      if (continueCount) {
        --continueCount;
        continue;
      }
      switch (letter = str.charAt(i)) {
        case '\\':
          ++continueCount;
          continue;
        case end:
          stack.pop();
          if (!stack.length) {
            return str.slice(0, +i + 1 || 9e9);
          }
          end = stack[stack.length - 1];
          continue;
      }
      if (end === '}' && (letter === '"' || letter === "'")) {
        stack.push(end = letter);
      } else if (end === '}' && letter === '/' && (match = HEREGEX.exec(str.slice(i)) || REGEX.exec(str.slice(i)))) {
        continueCount += match[0].length - 1;
      } else if (end === '}' && letter === '{') {
        stack.push(end = '}');
      } else if (end === '"' && prev === '#' && letter === '{') {
        stack.push(end = '}');
      }
      prev = letter;
    }
    return this.error("missing " + (stack.pop()) + ", starting");
  };

  return Parser;

})();

OPENING_TAG = /^<([-A-Za-z0-9_]+)((?:\s+[\w-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|(?:{[\s\S]*?})|[^>\s]+))?)*?\s*)(\/?)>/;

CLOSING_TAG = /^<\/([-A-Za-z0-9_]+)[^>]*>/;

TAG_ATTRIBUTES = /(?:([-A-Za-z0-9_]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|(?:{((?:\\.|[\s\S])*)})|([^>\s]+)))?)|([\s\n]+)/;

PRAGMA = /^\s*#\s*@cjsx\s+(\S*)/i;

BOM = 65279;

WHITESPACE = /^[^\n\S]+/;

COMMENT = /^###([^#][\s\S]*?)(?:###[^\n\S]*|###$)|^(?:\s*#(?!##[^#]).*)+/;

TRAILING_SPACES = /\s+$/;

HEREDOC = /^("""|''')((?:\\[\s\S]|[^\\])*?)(?:\n[^\n\S]*)?\1/;

SIMPLESTR = /^'[^\\']*(?:\\[\s\S][^\\']*)*'/;

JSTOKEN = /^`[^\\`]*(?:\\.[^\\`]*)*`/;

REGEX = /^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/;

HEREGEX = /^\/{3}((?:\\?[\s\S])+?)\/{3}([imgy]{0,4})(?!\w)/;

},{"./helpers":2,"./symbols":8,"util":13}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var $, HTML_ELEMENTS, SPACES_ONLY, TEXT_LEADING_WHITESPACE, TEXT_TRAILING_WHITESPACE, WHITESPACE_ONLY, containsNewlines, genericBranchSerialiser, genericLeafSerialiser, inspect, last, occurrences, serialise, serialiseNode, serialisers, stringEscape;

last = require('./helpers').last;

inspect = require('util').inspect;

$ = require('./symbols');

HTML_ELEMENTS = require('./htmlelements');

stringEscape = require('./stringescape');

occurrences = require('./occurrences');

module.exports = serialise = function(parseTree) {
  var env;
  env = {
    serialiseNode: serialiseNode
  };
  if (parseTree.children && parseTree.children.length && parseTree.children[0].type === $.CJSX_PRAGMA) {
    env.domObject = parseTree.children[0].value;
  } else {
    env.domObject = 'React.DOM';
  }
  return env.serialiseNode(parseTree);
};

serialiseNode = function(node) {
  var serialised;
  if (serialisers[node.type] == null) {
    throw new Error("unknown parseTree node type " + node.type);
  }
  serialised = serialisers[node.type](node, this);
  if (!(typeof serialised === 'string' || serialised === null)) {
    throw new Error("serialiser " + node.type + " didn\'t return a string for node " + (inspect(node)) + ", instead returned " + serialised);
  }
  return serialised;
};

genericBranchSerialiser = function(node, env) {
  return node.children.map(function(child) {
    return env.serialiseNode(child);
  }).join('');
};

genericLeafSerialiser = function(node, env) {
  return node.value;
};

serialise.serialisers = serialisers = {
  ROOT: genericBranchSerialiser,
  CJSX_PRAGMA: function() {
    return null;
  },
  CJSX_EL: function(node, env) {
    var accumulatedWhitespace, child, prefix, serialisedChild, serialisedChildren, _i, _len, _ref;
    serialisedChildren = [];
    accumulatedWhitespace = '';
    _ref = node.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      serialisedChild = env.serialiseNode(child);
      if (child != null) {
        if (WHITESPACE_ONLY.test(serialisedChild)) {
          accumulatedWhitespace += serialisedChild;
        } else {
          serialisedChildren.push(accumulatedWhitespace + serialisedChild);
          accumulatedWhitespace = '';
        }
      }
    }
    if (serialisedChildren.length) {
      serialisedChildren[serialisedChildren.length - 1] += accumulatedWhitespace;
      accumulatedWhitespace = '';
    }
    prefix = HTML_ELEMENTS[node.value] != null ? env.domObject + '.' : '';
    return prefix + node.value + '(' + serialisedChildren.join(', ') + ')';
  },
  CJSX_ESC: function(node, env) {
    var childrenSerialised;
    childrenSerialised = node.children.map(function(child) {
      return env.serialiseNode(child);
    }).join('');
    return '(' + childrenSerialised + ')';
  },
  CJSX_ATTRIBUTES: function(node, env) {
    var child, childIndex, indexOfLastSemanticChild, isBeforeLastSemanticChild, semanticChildren, serialisedChild, serialisedChildren, whitespaceChildren, _ref;
    _ref = node.children.reduce(function(partitionedChildren, child) {
      if (child.type === $.CJSX_WHITESPACE) {
        partitionedChildren[0].push(child);
      } else {
        partitionedChildren[1].push(child);
      }
      return partitionedChildren;
    }, [[], []]), whitespaceChildren = _ref[0], semanticChildren = _ref[1];
    indexOfLastSemanticChild = node.children.lastIndexOf(last(semanticChildren));
    isBeforeLastSemanticChild = function(childIndex) {
      return childIndex < indexOfLastSemanticChild;
    };
    if (semanticChildren.length) {
      serialisedChildren = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = node.children;
        _results = [];
        for (childIndex = _i = 0, _len = _ref1.length; _i < _len; childIndex = ++_i) {
          child = _ref1[childIndex];
          serialisedChild = env.serialiseNode(child);
          if (child.type === $.CJSX_WHITESPACE) {
            if (containsNewlines(serialisedChild)) {
              if (isBeforeLastSemanticChild(childIndex)) {
                _results.push(serialisedChild.replace('\n', ' \\\n'));
              } else {
                _results.push(serialisedChild);
              }
            } else {
              _results.push(null);
            }
          } else if (isBeforeLastSemanticChild(childIndex)) {
            _results.push(serialisedChild + ', ');
          } else {
            _results.push(serialisedChild);
          }
        }
        return _results;
      })();
      return '{' + serialisedChildren.join('') + '}';
    } else {
      return 'null';
    }
  },
  CJSX_ATTR_PAIR: function(node, env) {
    return node.children.map(function(child) {
      return env.serialiseNode(child);
    }).join(': ');
  },
  CS: genericLeafSerialiser,
  CS_COMMENT: genericLeafSerialiser,
  CS_HEREDOC: genericLeafSerialiser,
  CS_STRING: genericLeafSerialiser,
  CS_REGEX: genericLeafSerialiser,
  CS_HEREGEX: genericLeafSerialiser,
  JS_ESC: genericLeafSerialiser,
  CJSX_WHITESPACE: genericLeafSerialiser,
  CJSX_TEXT: function(node) {
    var leftSpace, leftTrim, rightSpace, rightTrim, text, trimmedText;
    text = node.value;
    if (containsNewlines(text)) {
      if (WHITESPACE_ONLY.test(text)) {
        return text;
      } else {
        leftSpace = text.match(TEXT_LEADING_WHITESPACE);
        rightSpace = text.match(TEXT_TRAILING_WHITESPACE);
        if (leftSpace) {
          leftTrim = text.indexOf('\n');
        } else {
          leftTrim = 0;
        }
        if (rightSpace) {
          rightTrim = text.lastIndexOf('\n') + 1;
        } else {
          rightTrim = text.length;
        }
        trimmedText = text.substring(leftTrim, rightTrim);
        return '"""' + trimmedText + '"""';
      }
    } else {
      if (text === '') {
        return null;
      } else {
        return '"' + text + '"';
      }
    }
  },
  CJSX_ATTR_KEY: genericLeafSerialiser,
  CJSX_ATTR_VAL: genericLeafSerialiser
};

containsNewlines = function(text) {
  return text.indexOf('\n') > -1;
};

SPACES_ONLY = /^\s+$/;

WHITESPACE_ONLY = /^[\n\s]+$/;

TEXT_LEADING_WHITESPACE = /^\s*?\n\s*/;

TEXT_TRAILING_WHITESPACE = /\s*?\n\s*?$/;

},{"./helpers":2,"./htmlelements":3,"./occurrences":4,"./stringescape":7,"./symbols":8,"util":13}],7:[function(require,module,exports){

var hex=new Array('0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f');

module.exports = function stringEncode(preescape)
{
	var escaped="";

	var i=0;
	for(i=0;i<preescape.length;i++)
	{
		escaped=escaped+encodeCharx(preescape.charAt(i));
	}

	return escaped;
}

function encodeCharx(original)
{
	var found=true;
	var thecharchar=original.charAt(0);
	var thechar=original.charCodeAt(0);
	switch(thecharchar) {
		case '\n': return "\\n"; break; //newline
		case '\r': return "\\r"; break; //Carriage return
		case '\'': return "\\'"; break;
		case '"': return "\\\""; break;
		case '\&': return "\\&"; break;
		case '\\': return "\\\\"; break;
		case '\t': return "\\t"; break;
		case '\b': return "\\b"; break;
		case '\f': return "\\f"; break;
		case '/': return "\\x2F"; break;
		case '<': return "\\x3C"; break;
		case '>': return "\\x3E"; break;
		default:
			found=false;
			break;
	}
	if(!found)
	{
		if(thechar>127) {
			var c=thechar;
			var a4=c%16;
			c=Math.floor(c/16);
			var a3=c%16;
			c=Math.floor(c/16);
			var a2=c%16;
			c=Math.floor(c/16);
			var a1=c%16;
		//	alert(a1);
			return "\\u"+hex[a1]+hex[a2]+hex[a3]+hex[a4]+"";
		}
		else
		{
			return original;
		}
	}
}

},{}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
module.exports = {
  ROOT: 'ROOT',
  CJSX_EL: 'CJSX_EL',
  CJSX_ESC: 'CJSX_ESC',
  CJSX_ATTRIBUTES: 'CJSX_ATTRIBUTES',
  CJSX_ATTR_PAIR: 'CJSX_ATTR_PAIR',
  CS: 'CS',
  CS_COMMENT: 'CS_COMMENT',
  CS_HEREDOC: 'CS_HEREDOC',
  CS_STRING: 'CS_STRING',
  CS_REGEX: 'CS_REGEX',
  CS_HEREGEX: 'CS_HEREGEX',
  JS_ESC: 'JS_ESC',
  CJSX_WHITESPACE: 'CJSX_WHITESPACE',
  CJSX_TEXT: 'CJSX_TEXT',
  CJSX_ATTR_KEY: 'CJSX_ATTR_KEY',
  CJSX_ATTR_VAL: 'CJSX_ATTR_VAL',
  CJSX_START: 'CJSX_START',
  CJSX_END: 'CJSX_END',
  CJSX_ESC_START: 'CJSX_ESC_START',
  CJSX_ESC_END: 'CJSX_ESC_END',
  CJSX_PRAGMA: 'CJSX_PRAGMA'
};

},{}],9:[function(require,module,exports){
(function (global){
// Generated by CoffeeScript 1.7.1
var Parser, serialise;

Parser = require('./parser');

serialise = require('./serialiser');

CJSXTransformer.transform = function(code, opts) {
  return serialise(new Parser().parse(code, opts));
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./parser":5,"./serialiser":6}],10:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],11:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],12:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],13:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require("q+64fw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":12,"inherits":10,"q+64fw":11}]},{},[1])
